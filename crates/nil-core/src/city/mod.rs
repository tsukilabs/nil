// Copyright (C) Call of Nil contributors
// SPDX-License-Identifier: AGPL-3.0-only

mod stability;

use crate::continent::Coord;
use crate::error::Result;
use crate::infrastructure::{Infrastructure, InfrastructureStats};
use crate::npc::bot::BotId;
use crate::npc::precursor::PrecursorId;
use crate::player::PlayerId;
use crate::ranking::Score;
use crate::resources::{Maintenance, Resources};
use crate::ruler::Ruler;
use bon::Builder;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

pub use stability::Stability;

#[derive(Builder, Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct City {
  #[builder(start_fn, into)]
  coord: Coord,

  #[builder(into)]
  name: String,

  #[builder(into)]
  owner: Ruler,

  #[builder(default)]
  infrastructure: Infrastructure,

  #[builder(default)]
  stability: Stability,
}

impl City {
  #[inline]
  pub fn coord(&self) -> Coord {
    self.coord
  }

  #[inline]
  pub fn name(&self) -> &str {
    &self.name
  }

  pub(crate) fn name_mut(&mut self) -> &mut String {
    &mut self.name
  }

  #[inline]
  pub fn owner(&self) -> &Ruler {
    &self.owner
  }

  #[inline]
  pub fn infrastructure(&self) -> &Infrastructure {
    &self.infrastructure
  }

  #[inline]
  pub fn infrastructure_mut(&mut self) -> &mut Infrastructure {
    &mut self.infrastructure
  }

  #[inline]
  pub fn stability(&self) -> Stability {
    self.stability
  }

  pub(crate) fn stability_mut(&mut self) -> &mut Stability {
    &mut self.stability
  }

  #[inline]
  pub fn player(&self) -> Option<PlayerId> {
    self.owner().player().cloned()
  }

  /// Checks whether the city belongs to a player.
  #[inline]
  pub fn is_owned_by_player(&self) -> bool {
    self.owner.player().is_some()
  }

  pub fn is_owned_by_player_and<F>(&self, f: F) -> bool
  where
    F: FnOnce(&PlayerId) -> bool,
  {
    self.owner.player().is_some_and(f)
  }

  /// Checks whether the city belongs to a bot.
  #[inline]
  pub fn is_owned_by_bot(&self) -> bool {
    self.owner.bot().is_some()
  }

  pub fn is_owned_by_bot_and<F>(&self, f: F) -> bool
  where
    F: FnOnce(&BotId) -> bool,
  {
    self.owner.bot().is_some_and(f)
  }

  /// Checks whether the city belongs to a precursor.
  #[inline]
  pub fn is_owned_by_precursor(&self) -> bool {
    self.owner.precursor().is_some()
  }

  pub fn is_owned_by_precursor_and<F>(&self, f: F) -> bool
  where
    F: FnOnce(PrecursorId) -> bool,
  {
    self.owner.precursor().is_some_and(f)
  }

  #[inline]
  pub fn score(&self, stats: &InfrastructureStats) -> Result<Score> {
    self.infrastructure.score(stats)
  }

  /// Determines the amount of resources generated by the city's mines
  /// while applying all relevant modifiers, such as city stability.
  pub fn round_production(&self, stats: &InfrastructureStats) -> Result<Resources> {
    let mut resources = self
      .infrastructure
      .round_base_production(stats)?;

    resources.food *= self.stability;
    resources.iron *= self.stability;
    resources.stone *= self.stability;
    resources.wood *= self.stability;

    Ok(resources)
  }

  /// Determines the maintenance tax required for the city buildings.
  pub fn maintenance(&self, stats: &InfrastructureStats) -> Result<Maintenance> {
    self.infrastructure.base_maintenance(stats)
  }
}

/// Public data about a city, to which any player can have access.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PublicCity {
  coord: Coord,
  name: Arc<str>,
  owner: Ruler,
}

impl From<&City> for PublicCity {
  fn from(city: &City) -> Self {
    Self {
      coord: city.coord,
      name: Arc::from(city.name.as_str()),
      owner: city.owner.clone(),
    }
  }
}
