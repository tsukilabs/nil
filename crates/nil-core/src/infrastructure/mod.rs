// Copyright (C) Call of Nil contributors
// SPDX-License-Identifier: AGPL-3.0-only

pub mod building;
pub mod mine;
pub mod prelude;
pub mod queue;
pub mod requirements;
pub mod stats;
pub mod storage;

use crate::error::Result;
use crate::infrastructure::building::academy::AcademyRecruitOrderId;
use crate::infrastructure::building::stable::StableRecruitOrderId;
use crate::military::army::ArmyPersonnel;
use crate::military::squad::Squad;
use crate::ranking::Score;
use crate::resources::{Maintenance, Resources};
use bon::Builder;
use building::academy::{AcademyRecruitOrder, AcademyRecruitOrderRequest};
use building::prefecture::{
  PrefectureBuildOrder,
  PrefectureBuildOrderKind,
  PrefectureBuildOrderRequest,
};
use building::stable::{StableRecruitOrder, StableRecruitOrderRequest};
use building::{Building, BuildingId, BuildingStatsTable, MineId, StorageId};
use mine::Mine;
use prelude::*;
use serde::{Deserialize, Serialize};
use storage::Storage;

pub use stats::InfrastructureStats;
use strum::IntoEnumIterator;

#[derive(Builder, Clone, Debug, Default, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Infrastructure {
  #[builder(default)]
  academy: Academy,

  #[builder(default)]
  farm: Farm,

  #[builder(default)]
  iron_mine: IronMine,

  #[builder(default)]
  prefecture: Prefecture,

  #[builder(default)]
  quarry: Quarry,

  #[builder(default)]
  sawmill: Sawmill,

  #[builder(default)]
  silo: Silo,

  #[builder(default)]
  stable: Stable,

  #[builder(default)]
  wall: Wall,

  #[builder(default)]
  warehouse: Warehouse,
}

impl Infrastructure {
  #[inline]
  pub fn new() -> Self {
    Self::default()
  }

  /// Creates a new instance with all buildings set to their maximum level.
  pub fn with_max_level() -> Self {
    Self {
      academy: Academy::with_max_level(),
      farm: Farm::with_max_level(),
      iron_mine: IronMine::with_max_level(),
      prefecture: Prefecture::with_max_level(),
      quarry: Quarry::with_max_level(),
      sawmill: Sawmill::with_max_level(),
      silo: Silo::with_max_level(),
      stable: Stable::with_max_level(),
      wall: Wall::with_max_level(),
      warehouse: Warehouse::with_max_level(),
    }
  }

  pub const fn building(&self, id: BuildingId) -> &dyn Building {
    match id {
      BuildingId::Academy => &self.academy,
      BuildingId::Farm => &self.farm,
      BuildingId::IronMine => &self.iron_mine,
      BuildingId::Prefecture => &self.prefecture,
      BuildingId::Quarry => &self.quarry,
      BuildingId::Sawmill => &self.sawmill,
      BuildingId::Silo => &self.silo,
      BuildingId::Stable => &self.stable,
      BuildingId::Wall => &self.wall,
      BuildingId::Warehouse => &self.warehouse,
    }
  }

  pub(crate) const fn building_mut(&mut self, id: BuildingId) -> &mut dyn Building {
    match id {
      BuildingId::Academy => &mut self.academy,
      BuildingId::Farm => &mut self.farm,
      BuildingId::IronMine => &mut self.iron_mine,
      BuildingId::Prefecture => &mut self.prefecture,
      BuildingId::Quarry => &mut self.quarry,
      BuildingId::Sawmill => &mut self.sawmill,
      BuildingId::Silo => &mut self.silo,
      BuildingId::Stable => &mut self.stable,
      BuildingId::Wall => &mut self.wall,
      BuildingId::Warehouse => &mut self.warehouse,
    }
  }

  pub const fn storage(&self, id: StorageId) -> &dyn Storage {
    match id {
      StorageId::Silo => &self.silo,
      StorageId::Warehouse => &self.warehouse,
    }
  }

  pub const fn mine(&self, id: MineId) -> &dyn Mine {
    match id {
      MineId::Farm => &self.farm,
      MineId::IronMine => &self.iron_mine,
      MineId::Quarry => &self.quarry,
      MineId::Sawmill => &self.sawmill,
    }
  }

  #[inline]
  pub const fn academy(&self) -> &Academy {
    &self.academy
  }

  #[inline]
  pub const fn farm(&self) -> &Farm {
    &self.farm
  }

  #[inline]
  pub const fn iron_mine(&self) -> &IronMine {
    &self.iron_mine
  }

  #[inline]
  pub const fn prefecture(&self) -> &Prefecture {
    &self.prefecture
  }

  #[inline]
  pub const fn quarry(&self) -> &Quarry {
    &self.quarry
  }

  #[inline]
  pub const fn sawmill(&self) -> &Sawmill {
    &self.sawmill
  }

  #[inline]
  pub const fn silo(&self) -> &Silo {
    &self.silo
  }

  #[inline]
  pub const fn stable(&self) -> &Stable {
    &self.stable
  }

  #[inline]
  pub const fn wall(&self) -> &Wall {
    &self.wall
  }

  #[inline]
  pub const fn warehouse(&self) -> &Warehouse {
    &self.warehouse
  }

  pub fn score(&self, stats: &InfrastructureStats) -> Result<Score> {
    let mut score = Score::default();
    for id in BuildingId::iter() {
      let level = self.building(id).level();
      if level > 0 {
        let stats = stats.building(id)?;
        score += stats.get(level)?.score;
      }
    }

    Ok(score)
  }

  /// Determines the amount of resources generated by the mines at their current level,
  /// before applying any modifiers, such as city stability.
  pub fn round_base_production(&self, stats: &InfrastructureStats) -> Result<Resources> {
    let mut resources = Resources::default();

    macro_rules! set {
      ($id:ident, $mine:ident, $resource:ident) => {
        let mine = &self.$mine;
        if mine.level() > 0u8 && mine.is_enabled() {
          let mine_stats = stats.mine(MineId::$id)?;
          resources.$resource = mine.production(mine_stats)?.into();
        }
      };
    }

    set!(Farm, farm, food);
    set!(IronMine, iron_mine, iron);
    set!(Quarry, quarry, stone);
    set!(Sawmill, sawmill, wood);

    Ok(resources)
  }

  /// Determines the maintenance tax required for all buildings at their current levels.
  pub fn base_maintenance(&self, stats: &InfrastructureStats) -> Result<Maintenance> {
    let mut maintenance = Maintenance::default();

    macro_rules! add {
      ($id:ident, $building:ident) => {
        let building = &self.$building;
        if building.level() > 0u8 && building.is_enabled() {
          let building_stats = stats.building(BuildingId::$id)?;
          maintenance += building.maintenance(&building_stats)?;
        }
      };
    }

    add!(Academy, academy);
    add!(Farm, farm);
    add!(IronMine, iron_mine);
    add!(Prefecture, prefecture);
    add!(Quarry, quarry);
    add!(Sawmill, sawmill);
    add!(Silo, silo);
    add!(Stable, stable);
    add!(Wall, wall);
    add!(Warehouse, warehouse);

    Ok(maintenance)
  }

  pub(crate) fn add_prefecture_build_order(
    &mut self,
    request: &PrefectureBuildOrderRequest,
    table: &BuildingStatsTable,
    current_resources: Option<&Resources>,
  ) -> Result<&PrefectureBuildOrder> {
    let level = self.building(request.building).level();
    self
      .prefecture
      .build_queue_mut()
      .build(request, table, level, current_resources)
  }

  #[must_use]
  pub(crate) fn cancel_prefecture_build_order(&mut self) -> Option<PrefectureBuildOrder> {
    self.prefecture.build_queue_mut().cancel()
  }

  pub(crate) fn process_prefecture_build_queue(&mut self) {
    if let Some(orders) = self.prefecture.process_queue() {
      for order in orders {
        let building = self.building_mut(order.building());
        match order.kind() {
          PrefectureBuildOrderKind::Construction => building.increase_level(),
          PrefectureBuildOrderKind::Demolition => building.decrease_level(),
        }
      }
    }
  }

  pub(crate) fn add_academy_recruit_order(
    &mut self,
    request: &AcademyRecruitOrderRequest,
    current_resources: Option<&Resources>,
  ) -> Result<&AcademyRecruitOrder> {
    self
      .academy
      .recruit_queue_mut()
      .recruit(request, current_resources)
  }

  #[must_use]
  pub(crate) fn cancel_academy_recruit_order(
    &mut self,
    id: AcademyRecruitOrderId,
  ) -> Option<AcademyRecruitOrder> {
    self.academy.recruit_queue_mut().cancel(id)
  }

  #[must_use]
  pub(crate) fn process_academy_recruit_queue(&mut self) -> Option<ArmyPersonnel> {
    let personnel = self
      .academy
      .process_queue()?
      .into_iter()
      .map(Squad::from)
      .collect();

    Some(personnel)
  }

  pub(crate) fn add_stable_recruit_order(
    &mut self,
    request: &StableRecruitOrderRequest,
    current_resources: Option<&Resources>,
  ) -> Result<&StableRecruitOrder> {
    self
      .stable
      .recruit_queue_mut()
      .recruit(request, current_resources)
  }

  #[must_use]
  pub(crate) fn cancel_stable_recruit_order(
    &mut self,
    id: StableRecruitOrderId,
  ) -> Option<StableRecruitOrder> {
    self.stable.recruit_queue_mut().cancel(id)
  }

  #[must_use]
  pub(crate) fn process_stable_recruit_queue(&mut self) -> Option<ArmyPersonnel> {
    let personnel = self
      .stable
      .process_queue()?
      .into_iter()
      .map(Squad::from)
      .collect();

    Some(personnel)
  }
}
