// Copyright (C) Call of Nil contributors
// SPDX-License-Identifier: AGPL-3.0-only

mod owner;

use crate::continent::Coord;
use crate::error::Result;
use crate::infrastructure::{Infrastructure, InfrastructureStats};
use crate::npc::bot::BotId;
use crate::npc::precursor::PrecursorId;
use crate::player::PlayerId;
use crate::resources::{Maintenance, Resources};
use bon::Builder;
use derive_more::{Deref, Into};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

pub use owner::VillageOwner;

#[derive(Builder, Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Village {
  #[builder(start_fn, into)]
  coord: Coord,

  #[builder(into)]
  name: String,

  #[builder(into)]
  owner: VillageOwner,

  #[builder(default)]
  infrastructure: Infrastructure,

  #[builder(default)]
  stability: Stability,
}

impl Village {
  #[inline]
  pub fn coord(&self) -> Coord {
    self.coord
  }

  #[inline]
  pub fn name(&self) -> &str {
    &self.name
  }

  pub(crate) fn name_mut(&mut self) -> &mut String {
    &mut self.name
  }

  #[inline]
  pub fn owner(&self) -> &VillageOwner {
    &self.owner
  }

  #[inline]
  pub fn infrastructure(&self) -> &Infrastructure {
    &self.infrastructure
  }

  #[inline]
  pub fn infrastructure_mut(&mut self) -> &mut Infrastructure {
    &mut self.infrastructure
  }

  #[inline]
  pub fn stability(&self) -> Stability {
    self.stability
  }

  pub(crate) fn stability_mut(&mut self) -> &mut Stability {
    &mut self.stability
  }

  #[inline]
  pub fn player(&self) -> Option<PlayerId> {
    self.owner().player().cloned()
  }

  /// Checks whether the village belongs to a player.
  #[inline]
  pub fn is_owned_by_player(&self) -> bool {
    self.owner.player().is_some()
  }

  pub fn is_owned_by_player_and<F>(&self, f: F) -> bool
  where
    F: FnOnce(&PlayerId) -> bool,
  {
    self.owner.player().is_some_and(f)
  }

  /// Checks whether the village belongs to a bot.
  #[inline]
  pub fn is_owned_by_bot(&self) -> bool {
    self.owner.bot().is_some()
  }

  pub fn is_owned_by_bot_and<F>(&self, f: F) -> bool
  where
    F: FnOnce(BotId) -> bool,
  {
    self.owner.bot().is_some_and(f)
  }

  /// Checks whether the village belongs to a precursor.
  #[inline]
  pub fn is_owned_by_precursor(&self) -> bool {
    self.owner.precursor().is_some()
  }

  pub fn is_owned_by_precursor_and<F>(&self, f: F) -> bool
  where
    F: FnOnce(PrecursorId) -> bool,
  {
    self.owner.precursor().is_some_and(f)
  }

  /// Determines the amount of resources generated by the village's mines
  /// while applying all relevant modifiers, such as village stability.
  pub fn round_production(&self, stats: &InfrastructureStats) -> Result<Resources> {
    let mut resources = self
      .infrastructure
      .round_base_production(stats)?;

    resources.food *= self.stability;
    resources.iron *= self.stability;
    resources.stone *= self.stability;
    resources.wood *= self.stability;

    Ok(resources)
  }

  /// Determines the maintenance tax required for the village buildings.
  pub fn maintenance(&self, stats: &InfrastructureStats) -> Result<Maintenance> {
    self.infrastructure.base_maintenance(stats)
  }
}

/// Political stability of the village.
#[derive(Clone, Copy, Debug, Deref, Into, Deserialize, Serialize)]
pub struct Stability(f64);

impl Stability {
  pub const MIN: Stability = Stability(0.0);
  pub const MAX: Stability = Stability(1.0);

  #[inline]
  pub const fn new(value: f64) -> Self {
    Self(value.clamp(Self::MIN.0, Self::MAX.0))
  }
}

impl Default for Stability {
  fn default() -> Self {
    Self::MAX
  }
}

/// Public data about a village, to which any player can have access.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PublicVillage {
  coord: Coord,
  name: Arc<str>,
  owner: VillageOwner,
}

impl From<&Village> for PublicVillage {
  fn from(village: &Village) -> Self {
    Self {
      coord: village.coord,
      name: Arc::from(village.name.as_str()),
      owner: village.owner.clone(),
    }
  }
}
